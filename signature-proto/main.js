
/*
// Test
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
*/

function Signer(cv, pre_data=null, options={}){
	let self = this;
	let ctx = cv.getContext("2d");
	options = {
		"edit_mode": typeof options.edit_mode !== 'undefined'? options.edit_mode: false
	};
	// List of separated continuous lines
	let draws = [];
	// List of undo lines drawed
	let popped = [];
	// Current line in draw
	let draw = null;
	
	// Table of hash characters for data encoding and decoding
	const code_table = [
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
		'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
	];
	
	// Renders the actual signature to canvas
	function render(){
		ctx.clearRect(0, 0, cv.width, cv.height);
		
		ctx.lineWidth = 4;
		ctx.lineCap = "round";
		for (let di=0; di<draws.length; di++){
			let draw = draws[di];
			
			if (draw.length>1){
				ctx.beginPath();
				ctx.moveTo(draw[0][0], draw[0][1]);
				for (let pi=1; pi<draw.length; pi++){
					ctx.lineTo(draw[pi][0], draw[pi][1]);
				}
				ctx.stroke();
			}
			else if (draw.length==1){
				ctx.fillRect(draw[0][0]-2, draw[0][1]-2, 4, 4);
			}
		}
	}
	
	// Closes the current line and opens a new one
	function clip(){
		draw = [];
		draws.push(draw);
		popped = [];
	}
	
	// Adds a new coordinate for current line
	function move(x, y){
		draw.push([x, y]);
		render();
	}
	
	// Undo the last written line
	function undo(){
		if (options.edit_mode && draws.length > 0){
			popped.push(draws.pop());
		}
	}
	
	// Redo the last undo line
	function redo(){
		if (options.edit_mode && popped.length > 0){
			draws.push(popped.pop());
		}
	}
	
	// Converts the signature to a encoded text base
	self.encodeSignature = function(){
		// The first two characters is for signature description, current is only null (two 'A's)
		let encoded = 'AA';
		for (let di=0; di<draws.length; di++){
			let draw = draws[di];
			for (let pi=0; pi<draw.length; pi++){
				let point = draw[pi];
				let code1 = (point[0]&0x7FF)|(pi==(draw.length-1)? 0x800: 0);
				let code2 = (point[1]&0x7FF)|(pi==(draw.length-1)? 0x800: 0);
				code1 = code_table[code1&0x3F] + code_table[(code1>>6)&0x3F];
				code2 = code_table[code2&0x3F] + code_table[(code2>>6)&0x3F];
				encoded += code1+code2;
			}
		}
		return encoded;
	}
	
	// Decodes the signature from a encoded text base
	self.decodeSignature = function(encoded){
		draw = [];
		draws = [draw];
		popped = [];
		
		let i=2;
		let close = false;
		while (i<encoded.length){
			if (close){
				close = false;
				draw = [];
				draws.push(draw);
			}
			let code1 = code_table.indexOf(encoded[i+0]) | (code_table.indexOf(encoded[i+1])<<6);
			let code2 = code_table.indexOf(encoded[i+2]) | (code_table.indexOf(encoded[i+3])<<6);
			draw.push([code1&0x7FF, code2&0x7FF]);
			if ((code1&0x800) || (code2&0x800)){
				close = true;
			}
			i += 4;
		}
		render();
	}
	
	// External undo call
	self.undo = function(){
		undo();
		render();
	}
	
	// External redo call
	self.redo = function(){
		redo();
		render();
	}
	
	// Gesture holding control variable
	let _holding = false;
	
	// Setup events on canvas for editing
	if (options.edit_mode){
		cv.onmousedown = function(ev){
			let x = ev.clientX-cv.getBoundingClientRect().left;
			let y = ev.clientY-cv.getBoundingClientRect().top;
			_holding = true;
			
			clip();
			move(x, y);
		}
		
		cv.onmousemove = function(ev){
			let x = ev.clientX-cv.getBoundingClientRect().left;
			let y = ev.clientY-cv.getBoundingClientRect().top;
			
			if (_holding){
				move(x, y);
			}
		}
		
		cv.onmouseup = function(ev){
			_holding = false;
		}
		
		cv.ontouchstart = function(ev){
			let x = ev.touches[0].clientX-cv.getBoundingClientRect().left;
			let y = ev.touches[0].clientY-cv.getBoundingClientRect().top;
			_holding = true;
			
			clip();
			move(x, y);
		}
		
		cv.ontouchmove = function(ev){
			let x = ev.touches[0].clientX-cv.getBoundingClientRect().left;
			let y = ev.touches[0].clientY-cv.getBoundingClientRect().top;
			
			if (_holding){
				move(x, y);
			}
		}
		
		cv.ontouchend = function(ev){
			_holding = false;
		}
	}
}

let sig = new Signer(stylus, null, {"edit_mode": true});

save.onclick = function(){
	code.value = sig.encodeSignature();
}

load.onclick = function(){
	sig.decodeSignature(code.value);
}

undo.onclick = function(){
	sig.undo();
}

redo.onclick = function(){
	sig.redo();
}

// Setup key events for easy editing
window.addEventListener('keydown', function(ev){
	if (ev.ctrlKey){
		if (ev.key == 'z'){
			sig.undo();
		}
		if (ev.key == 'y'){
			sig.redo();
		}
	}
});
